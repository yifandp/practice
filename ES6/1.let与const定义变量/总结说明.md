## ES6中的let与const
> 这里结合ES5.1的变量声明方式var和function理解

### 关于let与var
- 在ES5.1中存在变量提升
    - var在预解释的时候，会首先把变量声明，但是并不会定义
    - function在预解释的时候，会首先把函数声明同时加定义
    - 在全局作用域下，使用var和function声明的变量会给window增加属性
- 在ES6中不允许使用变量提升
    - let没有变量提升，因此使用console打印，并不会提示undefined，而是直接报错
    ```
    console.log(a);
    let a = 1;
    ```
    - 在使用var时，可以将已经声明的变量再次声明，而在let声明后，再次声明是不允许的
    - 不会给window增加属性，使用 in 来检测window的属性，是检测不到的，甚至，window对象都被允许打印出来
- const在ES6中
    - 同let类似：没有变量提升，不可以重复声明，不会给window增加属性
    - 同时，const定义的是常量，var和let声明变量后，可以不赋值，但是const必须声明的时候就定义
    - var和let在声明和定以后，可以赋新值，但是const不允许再赋值。因为它是一个常量

### 块级作用域
> ``{}``,就是一个块级作用域，块级作用域下var和function声明的变量依然是全局的。即在块级作用域外面是可以访问的
> 但是块级作用域下let和const声明的变量是私有的，在外面是获取不到的

#### ``{name:"Cyan",age:19}``,这样写会报错，因为它们被当做成块级作用域
    - 因此，let obj = {name:"Cyan",age:19};
    - ({name:"Aqing",age:20})这两种方式都可以，声明对象，而不是被当做块级作用域

#### if中的块级作用域：
> if语句中的function只会提前声明，并不会同时定义，它的定义发生在if判断为真的时候，进入if作用域的第一件事就是，给function赋值，代码再执行

#### for循环中的块级作用域：
> 使用var声明的for循环中的循环值，在循环外是可以访问到的，也就是说，这个值是全局的。同时，这个值在外面访问时，是已经步长累加完的值。
> 使用let声明的for循环中的循环值，因为是属于块级作用域私有的，所以循环体外是访问不到的。
